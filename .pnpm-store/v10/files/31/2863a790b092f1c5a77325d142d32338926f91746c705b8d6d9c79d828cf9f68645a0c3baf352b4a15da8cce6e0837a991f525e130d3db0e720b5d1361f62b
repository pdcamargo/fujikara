{"version":3,"file":"serverFnFetcher.js","sources":["../../../src/client-rpc/serverFnFetcher.ts"],"sourcesContent":["import {\n  encode,\n  isNotFound,\n  isPlainObject,\n  parseRedirect,\n} from '@tanstack/router-core'\nimport { fromCrossJSON, toJSONAsync } from 'seroval'\nimport invariant from 'tiny-invariant'\nimport { getDefaultSerovalPlugins } from '../getDefaultSerovalPlugins'\nimport {\n  TSS_FORMDATA_CONTEXT,\n  X_TSS_RAW_RESPONSE,\n  X_TSS_SERIALIZED,\n} from '../constants'\nimport type { FunctionMiddlewareClientFnOptions } from '../createMiddleware'\nimport type { Plugin as SerovalPlugin } from 'seroval'\n\nlet serovalPlugins: Array<SerovalPlugin<any, any>> | null = null\n\nexport async function serverFnFetcher(\n  url: string,\n  args: Array<any>,\n  handler: (url: string, requestInit: RequestInit) => Promise<Response>,\n) {\n  if (!serovalPlugins) {\n    serovalPlugins = getDefaultSerovalPlugins()\n  }\n  const _first = args[0]\n\n  // If createServerFn was used to wrap the fetcher,\n  // We need to handle the arguments differently\n  if (isPlainObject(_first) && _first.method) {\n    const first = _first as FunctionMiddlewareClientFnOptions<any, any, any> & {\n      headers: HeadersInit\n    }\n    const type = first.data instanceof FormData ? 'formData' : 'payload'\n\n    // Arrange the headers\n    const headers = new Headers({\n      'x-tsr-redirect': 'manual',\n      ...(first.headers instanceof Headers\n        ? Object.fromEntries(first.headers.entries())\n        : first.headers),\n    })\n\n    if (type === 'payload') {\n      headers.set('accept', 'application/x-ndjson, application/json')\n    }\n\n    // If the method is GET, we need to move the payload to the query string\n    if (first.method === 'GET') {\n      if (type === 'formData') {\n        throw new Error('FormData is not supported with GET requests')\n      }\n      const serializedPayload = await serializePayload(first)\n      if (serializedPayload !== undefined) {\n        const encodedPayload = encode({\n          payload: await serializePayload(first),\n        })\n        if (url.includes('?')) {\n          url += `&${encodedPayload}`\n        } else {\n          url += `?${encodedPayload}`\n        }\n      }\n    }\n\n    if (url.includes('?')) {\n      url += `&createServerFn`\n    } else {\n      url += `?createServerFn`\n    }\n\n    let body = undefined\n    if (first.method === 'POST') {\n      const fetchBody = await getFetchBody(first)\n      if (fetchBody?.contentType) {\n        headers.set('content-type', fetchBody.contentType)\n      }\n      body = fetchBody?.body\n    }\n\n    return await getResponse(async () =>\n      handler(url, {\n        method: first.method,\n        headers,\n        signal: first.signal,\n        body,\n      }),\n    )\n  }\n\n  // If not a custom fetcher, it was probably\n  // a `use server` function, so just proxy the arguments\n  // through as a POST request\n  return await getResponse(() =>\n    handler(url, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(args),\n    }),\n  )\n}\n\nasync function serializePayload(\n  opts: FunctionMiddlewareClientFnOptions<any, any, any>,\n): Promise<string | undefined> {\n  let payloadAvailable = false\n  const payloadToSerialize: any = {}\n  if (opts.data !== undefined) {\n    payloadAvailable = true\n    payloadToSerialize['data'] = opts.data\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (opts.context && Object.keys(opts.context).length > 0) {\n    payloadAvailable = true\n    payloadToSerialize['context'] = opts.context\n  }\n\n  if (payloadAvailable) {\n    return serialize(payloadToSerialize)\n  }\n  return undefined\n}\n\nasync function serialize(data: any) {\n  return JSON.stringify(\n    await Promise.resolve(toJSONAsync(data, { plugins: serovalPlugins! })),\n  )\n}\n\nasync function getFetchBody(\n  opts: FunctionMiddlewareClientFnOptions<any, any, any>,\n): Promise<{ body: FormData | string; contentType?: string } | undefined> {\n  if (opts.data instanceof FormData) {\n    let serializedContext = undefined\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (opts.context && Object.keys(opts.context).length > 0) {\n      serializedContext = await serialize(opts.context)\n    }\n    if (serializedContext !== undefined) {\n      opts.data.set(TSS_FORMDATA_CONTEXT, serializedContext)\n    }\n    return { body: opts.data }\n  }\n  const serializedBody = await serializePayload(opts)\n  if (serializedBody) {\n    return { body: serializedBody, contentType: 'application/json' }\n  }\n  return undefined\n}\n\n/**\n * Retrieves a response from a given function and manages potential errors\n * and special response types including redirects and not found errors.\n *\n * @param fn - The function to execute for obtaining the response.\n * @returns The processed response from the function.\n * @throws If the response is invalid or an error occurs during processing.\n */\nasync function getResponse(fn: () => Promise<Response>) {\n  const response = await (async () => {\n    try {\n      return await fn()\n    } catch (error) {\n      if (error instanceof Response) {\n        return error\n      }\n      console.log(error)\n      throw error\n    }\n  })()\n\n  if (response.headers.get(X_TSS_RAW_RESPONSE) === 'true') {\n    return response\n  }\n  const contentType = response.headers.get('content-type')\n  invariant(contentType, 'expected content-type header to be set')\n  const serializedByStart = !!response.headers.get(X_TSS_SERIALIZED)\n  // If the response is not ok, throw an error\n  if (!response.ok) {\n    if (serializedByStart && contentType.includes('application/json')) {\n      const jsonPayload = await response.json()\n      const result = fromCrossJSON(jsonPayload, { plugins: serovalPlugins! })\n      throw result\n    }\n\n    throw new Error(await response.text())\n  }\n\n  if (serializedByStart) {\n    let result\n    if (contentType.includes('application/x-ndjson')) {\n      const refs = new Map()\n      result = await processServerFnResponse({\n        response,\n        onMessage: (msg) =>\n          fromCrossJSON(msg, { refs, plugins: serovalPlugins! }),\n        onError(msg, error) {\n          // TODO how could we notify consumer that an error occurred?\n          console.error(msg, error)\n        },\n      })\n    }\n    if (contentType.includes('application/json')) {\n      const jsonPayload = await response.json()\n      result = fromCrossJSON(jsonPayload, { plugins: serovalPlugins! })\n    }\n    invariant(result, 'expected result to be resolved')\n    if (result instanceof Error) {\n      throw result\n    }\n    return result\n  }\n\n  if (contentType.includes('application/json')) {\n    const jsonPayload = await response.json()\n    const redirect = parseRedirect(jsonPayload)\n    if (redirect) {\n      throw redirect\n    }\n    if (isNotFound(jsonPayload)) {\n      throw jsonPayload\n    }\n    return jsonPayload\n  }\n\n  return response\n}\n\nasync function processServerFnResponse({\n  response,\n  onMessage,\n  onError,\n}: {\n  response: Response\n  onMessage: (msg: any) => any\n  onError?: (msg: string, error?: any) => void\n}) {\n  if (!response.body) {\n    throw new Error('No response body')\n  }\n\n  const reader = response.body.pipeThrough(new TextDecoderStream()).getReader()\n\n  let buffer = ''\n  let firstRead = false\n  let firstObject\n\n  while (!firstRead) {\n    const { value, done } = await reader.read()\n    if (value) buffer += value\n\n    if (buffer.length === 0 && done) {\n      throw new Error('Stream ended before first object')\n    }\n\n    // common case: buffer ends with newline\n    if (buffer.endsWith('\\n')) {\n      const lines = buffer.split('\\n').filter(Boolean)\n      const firstLine = lines[0]\n      if (!firstLine) throw new Error('No JSON line in the first chunk')\n      firstObject = JSON.parse(firstLine)\n      firstRead = true\n      buffer = lines.slice(1).join('\\n')\n    } else {\n      // fallback: wait for a newline to parse first object safely\n      const newlineIndex = buffer.indexOf('\\n')\n      if (newlineIndex >= 0) {\n        const line = buffer.slice(0, newlineIndex).trim()\n        buffer = buffer.slice(newlineIndex + 1)\n        if (line.length > 0) {\n          firstObject = JSON.parse(line)\n          firstRead = true\n        }\n      }\n    }\n  }\n\n  // process rest of the stream asynchronously\n  ;(async () => {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      while (true) {\n        const { value, done } = await reader.read()\n        if (value) buffer += value\n\n        const lastNewline = buffer.lastIndexOf('\\n')\n        if (lastNewline >= 0) {\n          const chunk = buffer.slice(0, lastNewline)\n          buffer = buffer.slice(lastNewline + 1)\n          const lines = chunk.split('\\n').filter(Boolean)\n\n          for (const line of lines) {\n            try {\n              onMessage(JSON.parse(line))\n            } catch (e) {\n              onError?.(`Invalid JSON line: ${line}`, e)\n            }\n          }\n        }\n\n        if (done) {\n          break\n        }\n      }\n    } catch (err) {\n      onError?.('Stream processing error:', err)\n    }\n  })()\n\n  return onMessage(firstObject)\n}\n"],"names":[],"mappings":"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"}